diff --git a/src/java.base/share/classes/java/lang/AbstractStringBuilder.java b/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
index 187e041e6745a..8958aa868a72b 100644
--- a/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
+++ b/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -639,14 +639,11 @@ private AbstractStringBuilder appendNull() {
         int count = this.count;
         byte[] val = this.value;
         if (isLatin1()) {
-            val[count++] = 'n';
-            val[count++] = 'u';
-            val[count++] = 'l';
-            val[count++] = 'l';
+            StringLatin1.putCharsAt(val, count, 'n', 'u', 'l', 'l');
         } else {
-            count = StringUTF16.putCharsAt(val, count, 'n', 'u', 'l', 'l');
+            StringUTF16.putCharsAt(val, count, 'n', 'u', 'l', 'l');
         }
-        this.count = count;
+        this.count = count + 4;
         return this;
     }
 
@@ -771,25 +768,18 @@ public AbstractStringBuilder append(boolean b) {
         byte[] val = this.value;
         if (isLatin1()) {
             if (b) {
-                val[count++] = 't';
-                val[count++] = 'r';
-                val[count++] = 'u';
-                val[count++] = 'e';
+                StringLatin1.putCharsAt(val, count, 't', 'r', 'u', 'e');
             } else {
-                val[count++] = 'f';
-                val[count++] = 'a';
-                val[count++] = 'l';
-                val[count++] = 's';
-                val[count++] = 'e';
+                StringLatin1.putCharsAt(val, count, 'f', 'a', 'l', 's', 'e');
             }
         } else {
             if (b) {
-                count = StringUTF16.putCharsAt(val, count, 't', 'r', 'u', 'e');
+                StringUTF16.putCharsAt(val, count, 't', 'r', 'u', 'e');
             } else {
-                count = StringUTF16.putCharsAt(val, count, 'f', 'a', 'l', 's', 'e');
+                StringUTF16.putCharsAt(val, count, 'f', 'a', 'l', 's', 'e');
             }
         }
-        this.count = count;
+        this.count = count + (b ? 4 : 5);
         return this;
     }
 
diff --git a/src/java.base/share/classes/java/lang/StringLatin1.java b/src/java.base/share/classes/java/lang/StringLatin1.java
index abec36af1d9d7..c12b8afc21f37 100644
--- a/src/java.base/share/classes/java/lang/StringLatin1.java
+++ b/src/java.base/share/classes/java/lang/StringLatin1.java
@@ -32,6 +32,7 @@
 import java.util.function.IntConsumer;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+import jdk.internal.misc.Unsafe;
 import jdk.internal.util.ArraysSupport;
 import jdk.internal.util.DecimalDigits;
 import jdk.internal.vm.annotation.IntrinsicCandidate;
@@ -42,6 +43,8 @@
 import static java.lang.String.checkOffset;
 
 final class StringLatin1 {
+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
     public static char charAt(byte[] value, int index) {
         checkIndex(index, value.length);
         return (char)(value[index] & 0xff);
@@ -824,6 +827,27 @@ static Stream<String> lines(byte[] value) {
         return StreamSupport.stream(LinesSpliterator.spliterator(value), false);
     }
 
+    static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4) {
+        assert index >= 0 && index + 3 < length(val) : "Trusted caller missed bounds check";
+        // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.
+        long address  = Unsafe.ARRAY_BYTE_BASE_OFFSET + index;
+        UNSAFE.putByte(val, address    , (byte)(c1));
+        UNSAFE.putByte(val, address + 1, (byte)(c2));
+        UNSAFE.putByte(val, address + 2, (byte)(c3));
+        UNSAFE.putByte(val, address + 3, (byte)(c4));
+    }
+
+    static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4, int c5) {
+        assert index >= 0 && index + 4 < length(val) : "Trusted caller missed bounds check";
+        // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.
+        long address  = Unsafe.ARRAY_BYTE_BASE_OFFSET + index;
+        UNSAFE.putByte(val, address    , (byte)(c1));
+        UNSAFE.putByte(val, address + 1, (byte)(c2));
+        UNSAFE.putByte(val, address + 2, (byte)(c3));
+        UNSAFE.putByte(val, address + 3, (byte)(c4));
+        UNSAFE.putByte(val, address + 4, (byte)(c5));
+    }
+
     public static void putChar(byte[] val, int index, int c) {
         //assert (canEncode(c));
         val[index] = (byte)(c);
diff --git a/src/java.base/share/classes/java/lang/StringUTF16.java b/src/java.base/share/classes/java/lang/StringUTF16.java
index 000483f29bc9e..543e3618b5a66 100644
--- a/src/java.base/share/classes/java/lang/StringUTF16.java
+++ b/src/java.base/share/classes/java/lang/StringUTF16.java
@@ -43,7 +43,6 @@
 import static java.lang.String.LATIN1;
 
 final class StringUTF16 {
-
     // Return a new byte array for a UTF16-coded string for len chars
     // Throw an exception if out of range
     public static byte[] newBytesFor(int len) {
@@ -1548,27 +1547,38 @@ public static boolean contentEquals(byte[] value, CharSequence cs, int len) {
         return true;
     }
 
-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {
-        int end = i + 4;
-        checkBoundsBeginEnd(i, end, value);
-        putChar(value, i++, c1);
-        putChar(value, i++, c2);
-        putChar(value, i++, c3);
-        putChar(value, i++, c4);
-        assert(i == end);
-        return end;
-    }
-
-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {
-        int end = i + 5;
-        checkBoundsBeginEnd(i, end, value);
-        putChar(value, i++, c1);
-        putChar(value, i++, c2);
-        putChar(value, i++, c3);
-        putChar(value, i++, c4);
-        putChar(value, i++, c5);
-        assert(i == end);
-        return end;
+    static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4) {
+        assert index >= 0 && index + 3 < length(val) : "Trusted caller missed bounds check";
+        // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.
+        long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (index << 1);
+        Unsafe UNSAFE = Unsafe.getUnsafe();
+
+        UNSAFE.putByte(val, address    , (byte)(c1 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 1, (byte)(c1 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 2, (byte)(c2 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 3, (byte)(c2 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 4, (byte)(c3 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 5, (byte)(c3 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 6, (byte)(c4 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 7, (byte)(c4 >> LO_BYTE_SHIFT));
+    }
+
+    static void putCharsAt(byte[] val, int index, int c1, int c2, int c3, int c4, int c5) {
+        assert index >= 0 && index + 4 < length(val) : "Trusted caller missed bounds check";
+        // Don't use the putChar method, Its instrinsic will cause C2 unable to combining values into larger stores.
+        long address  = Unsafe.ARRAY_BYTE_BASE_OFFSET + (index << 1);
+        Unsafe UNSAFE = Unsafe.getUnsafe();
+
+        UNSAFE.putByte(val, address    , (byte)(c1 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 1, (byte)(c1 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 2, (byte)(c2 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 3, (byte)(c2 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 4, (byte)(c3 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 5, (byte)(c3 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 6, (byte)(c4 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 7, (byte)(c4 >> LO_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 8, (byte)(c5 >> HI_BYTE_SHIFT));
+        UNSAFE.putByte(val, address + 9, (byte)(c5 >> LO_BYTE_SHIFT));
     }
 
     public static char charAt(byte[] value, int index) {
diff --git a/test/hotspot/jtreg/compiler/intrinsics/string/TestStringUTF16IntrinsicRangeChecks.java b/test/hotspot/jtreg/compiler/intrinsics/string/TestStringUTF16IntrinsicRangeChecks.java
index 9cd40ac504fd6..50c716bed746d 100644
--- a/test/hotspot/jtreg/compiler/intrinsics/string/TestStringUTF16IntrinsicRangeChecks.java
+++ b/test/hotspot/jtreg/compiler/intrinsics/string/TestStringUTF16IntrinsicRangeChecks.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -108,13 +108,6 @@ public static void main(String[] args) throws Exception {
                 throw new AssertionError("append");
             }
 
-            putCharsAt(val2, -1, '1', '2', '3', '4');
-            putCharsAt(val2,  0, '1', '2', '3', '4');
-            putCharsAt(val2,  2, '1', '2', '3', '4');
-            putCharsAt(val2, -1, '1', '2', '3', '4', '5');
-            putCharsAt(val2,  0, '1', '2', '3', '4', '5');
-            putCharsAt(val2,  2, '1', '2', '3', '4', '5');
-
             reverse(valHigh, -1);
             reverse(valHigh,  2);
             reverse(valLow,  -1);
@@ -248,22 +241,6 @@ static void contentEquals(byte[] v, CharSequence cs, int len) {
         }
     }
 
-    static void putCharsAt(byte[] v, int i, char c1, char c2, char c3, char c4) {
-        try {
-            Helper.putCharsAt(v, i, c1, c2, c3, c4);
-            throw new AssertionError("putCharsAt");
-        } catch (IndexOutOfBoundsException io) {
-        }
-    }
-
-    static void putCharsAt(byte[] v, int i, char c1, char c2, char c3, char c4, char c5) {
-        try {
-            Helper.putCharsAt(v, i, c1, c2, c3, c4, c5);
-            throw new AssertionError("putCharsAt");
-        } catch (IndexOutOfBoundsException io) {
-        }
-    }
-
     static void reverse(byte[] v, int len) {
         try {
             Helper.reverse(v, len);
diff --git a/test/hotspot/jtreg/compiler/patches/java.base/java/lang/Helper.java b/test/hotspot/jtreg/compiler/patches/java.base/java/lang/Helper.java
index a24d7b98ada52..f41512334676a 100644
--- a/test/hotspot/jtreg/compiler/patches/java.base/java/lang/Helper.java
+++ b/test/hotspot/jtreg/compiler/patches/java.base/java/lang/Helper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -132,14 +132,6 @@ public static boolean contentEquals(byte[] value, CharSequence cs, int len) {
         return StringUTF16.contentEquals(value, cs, len);
     }
 
-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {
-        return StringUTF16.putCharsAt(value, i, c1, c2, c3, c4);
-    }
-
-    public static int putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {
-        return StringUTF16.putCharsAt(value, i, c1, c2, c3, c4, c5);
-    }
-
     public static char charAt(byte[] value, int index) {
         return StringUTF16.charAt(value, index);
     }
diff --git a/test/micro/org/openjdk/bench/java/lang/StringBuilders.java b/test/micro/org/openjdk/bench/java/lang/StringBuilders.java
index 29827b7f03a2f..a6b43ca0194c2 100644
--- a/test/micro/org/openjdk/bench/java/lang/StringBuilders.java
+++ b/test/micro/org/openjdk/bench/java/lang/StringBuilders.java
@@ -226,17 +226,66 @@ public String toStringCharWithInt8() {
 
 
     @Benchmark
-    public String toStringCharWithBool8() {
-        StringBuilder result = new StringBuilder();
-        result.append(true);
-        result.append(false);
-        result.append(true);
-        result.append(true);
-        result.append(false);
-        result.append(true);
-        result.append(false);
-        result.append(false);
-        return result.toString();
+    public int appendWithBool8Latin1() {
+        StringBuilder buf = sbLatin1;
+        buf.setLength(0);
+        buf.append(true);
+        buf.append(false);
+        buf.append(true);
+        buf.append(true);
+        buf.append(false);
+        buf.append(true);
+        buf.append(false);
+        buf.append(false);
+        return buf.length();
+    }
+
+
+    @Benchmark
+    public int appendWithBool8Utf16() {
+        StringBuilder buf = sbUtf16;
+        buf.setLength(0);
+        buf.append(true);
+        buf.append(false);
+        buf.append(true);
+        buf.append(true);
+        buf.append(false);
+        buf.append(true);
+        buf.append(false);
+        buf.append(false);
+        return buf.length();
+    }
+
+
+    @Benchmark
+    public int appendWithNull8Latin1() {
+        StringBuilder buf = sbLatin1;
+        buf.setLength(0);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        return buf.length();
+    }
+
+
+    @Benchmark
+    public int appendWithNull8Utf16() {
+        StringBuilder buf = sbUtf16;
+        buf.setLength(0);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        buf.append((String) null);
+        return buf.length();
     }
 
 
